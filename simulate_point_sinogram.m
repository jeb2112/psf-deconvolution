function [sino] = simulate_point_sinogram(sizes, steps, starts, psf, position)
%    """simulate the sinogram generated by a point at specified position that is degrade by the specified psf

%    sizes  :  (Nx, Nphi)   dimensions of image
%    steps  :  (sx, sphi)   voxel size in x and l dimensions
%    starts :  (cx, cphi)   centre of 0,0 voxel
%    psf    :  ArrayVolume specifying psf
%    position :  position or point object 

%    Note centre of rotation is assumed to be at x = 0, y = 0

% alloc array
sino = py_minc.ArrayVolume((1, sizes(1), sizes(2)), dimension_names = ('zspace', 'xspace', 'phispace'), 
nc_data_type = py_minc.NC_SHORT, typecode = float_);
sino.set_starts((0, starts(1), starts(2)));
sino.set_separations((1, steps(1), steps(2)));

% convert point location to polar coordinates
r = sqrt(position(1)^2+position(2)^2);
theta = arctan2(position(1), position(2));

psf_starts = psf.get_starts();
psf_steps = psf.get_separations();
psf_sizes = psf.get_sizes();
x_values = psf_starts(2) + arange(psf_sizes(2))*psf_steps(2);
l_values = psf_starts(3) + arange(psf_sizes(3))*psf_steps(3);
interp_psf = bilinear_interp(x_values, l_values, psf.array(1));

% iterate over angles
for j=1:sizes(2)
  phi = starts(2) + j*steps(2);
  dphi = phi - theta; % relative rotation of point
  offset = r*sin(dphi);  % compute position of rotated point in detector coord (x,l)
  l = r*cos(dphi);
  
% iterate over detector elements
  for i=1:sizes(1)
    x = starts(1) + i*steps(1);
    dx = offset - x;   % coordinate relative to centre
    sino.array[0,i,j] = interp_psf(dx, l);
  end
end

return
