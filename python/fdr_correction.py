
#  A library of functions for testing frequency distance rule correction of 2D data

#  Created by John G. Sled
#  Last updated:  January 13, 2011



from numpy import *
import scipy
from scipy import interpolate, fftpack
import py_minc
from scipy.interpolate import RectBivariateSpline

def simulate_2d_gaussian_psf(sizes, steps, starts, centre, width, depth_dependent_width):
    """simulate the image of point source at location centre in
    translated along dimension l and having a gaussian profile in x
    with a minimum width specified by width and an optional l (or
    depth dependence)

    sizes :  (Nx, Nl)   dimensions of simulated image
    steps :  (sx, sl)   voxel size in x and l dimensions
    starts : (cx, cl)   centre of 0,0 voxel
    width  :  width in x of gaussian
    depth_dependent_width : additional width term which is proportional to l-cl and combines in quadrature with base width
    """

    # alloc array
    img = py_minc.ArrayVolume((1, sizes[0], sizes[1]), dimension_names = ('zspace', 'xspace', 'lspace'), 
                        nc_data_type = py_minc.NC_SHORT, typecode = float_)
    img.set_starts((0, starts[0], starts[1]))
    img.set_separations((1, steps[0], steps[1]))
                  
    # iterate over voxels
    for j in range(sizes[1]):
        l = starts[1] + j*steps[1]
        dl = l - centre[1] # coordinate relative to focal plane

        combined_width_sq = width**2 + (dl*depth_dependent_width)**2
        c = 1.0/sqrt(2*pi*combined_width_sq)

        for i in range(sizes[0]):
            x = starts[0] + i*steps[0]
            dx = x - centre[0]   # coordinate relative to centre
            
            img.array[0,i,j] = c*exp(-.5*dx**2/combined_width_sq) # evaluate gaussian
    
    return img


def simulate_point_sinogram(sizes, steps, starts, psf, position):
    """simulate the sinogram generated by a point at specified position that is degrade by the specified psf

    sizes  :  (Nx, Nphi)   dimensions of image
    steps  :  (sx, sphi)   voxel size in x and l dimensions
    starts :  (cx, cphi)   centre of 0,0 voxel
    psf    :  ArrayVolume specifying psf
    position :  position or point object 

    Note centre of rotation is assumed to be at x = 0, y = 0
    """

    # alloc array
    sino = py_minc.ArrayVolume((1, sizes[0], sizes[1]), dimension_names = ('zspace', 'xspace', 'phispace'), 
                        nc_data_type = py_minc.NC_SHORT, typecode = float_)
    sino.set_starts((0, starts[0], starts[1]))
    sino.set_separations((1, steps[0], steps[1]))
    
    # convert point location to polar coordinates
    r = sqrt(position[0]**2+position[1]**2)
    theta = arctan2(position[0], position[1])
    
    psf_starts = psf.get_starts()
    psf_steps = psf.get_separations()
    psf_sizes = psf.get_sizes()
    x_values = psf_starts[1] + arange(psf_sizes[1])*psf_steps[1]
    l_values = psf_starts[2] + arange(psf_sizes[2])*psf_steps[2]
    interp_psf = bilinear_interp(x_values, l_values, psf.array[0])
    
    # iterate over angles
    for j in range(sizes[1]):
        phi = starts[1] + j*steps[1]
        dphi = phi - theta # relative rotation of point
        offset = r*sin(dphi)  # compute position of rotated point in detector coord (x,l)
        l = r*cos(dphi)
        
        # iterate over detector elements
        for i in range(sizes[0]):
            x = starts[0] + i*steps[0]
            dx = offset - x   # coordinate relative to centre
            sino.array[0,i,j] = interp_psf(dx, l)
    
    return sino
def limit_recovery_filter(sizes, steps, starts, fdr_inv, fdrlimit=5):
    """compute the limit recovery filter of fdr 
    sizes  :  (Nx, Nphi)   dimensions of image
    steps  :  (sx, sphi)   voxel size in x and l dimensions
    starts :  (cx, cphi)   centre of 0,0 voxel
    fdr_inv    :  inverse fdr filter

    """
    # alloc array
    limit_recovery = zeros([sizes[0],sizes[1]], complex_)
    ## defined in jwcode
    Ct=fdrlimit
    Cr=fdrlimit/2
    ##defined in paper
    #Ct=1e-3
    #Cr=1e-4
    for j in range(sizes[1]):        
        # iterate over detector elements
        for i in range(sizes[0]):
            val1 = abs(fdr_inv[i,j])
            if(val1 > Ct): 
                val2 = Ct+Cr - Cr*exp(-(val1-Ct)/Cr)
                limit_recovery[i,j] *= val2/val1
            else:
                limit_recovery[i,j] = fdr_inv[i,j]

    return limit_recovery

def roll_off_filter(sizes, steps, starts, weight=300, maxslope=0.95):
    """compute roll off filter 
    sizes  :  (Nx, Nphi)   dimensions of image
    steps  :  (sx, sphi)   voxel size in x and l dimensions
    starts :  (cx, cphi)   centre of 0,0 voxel

    """
    print sizes
    print steps
    print starts
    # alloc array
    roll_off = zeros([sizes[0],sizes[1]])
    # evaluate each voxel
    for j in range(sizes[1]):  # for each angular frequency
        for i in range(sizes[0]):  # for each detector spatial frequency
            phi = starts[1] + j*steps[1]
            rx = starts[0] + i*steps[0]
           
            if (abs(rx) > 1e-9):
                #l = -phi/rx   # convert slope to depth changed to positive
                l = phi/rx 
                #print l
                if (l <= 0):
                    roll_off[i,j] = 1.0
                elif ( l < weight):
                    roll_off[i,j] = cos(pi/2.0*abs(l)/weight)**2
                else:
                    roll_off[i,j] = 0.0
            else:
                roll_off[i,j] = 0.0
    return roll_off

def band_limit_filter(sizes, steps, starts, bandlimit=0.9):
    """compute band limit filter 
    sizes  :  (Nx, Nphi)   dimensions of image
    steps  :  (sx, sphi)   voxel size in x and l dimensions
    starts :  (cx, cphi)   centre of 0,0 voxel

    """
    # alloc array
    band_limit = zeros([sizes[0],sizes[1]])
    # find the right bandlimit (so the code says!!)
    bw_i = bandlimit*(sizes[0])/(4.5*1000)
    bw_j = bandlimit*(sizes[1])/(4.5*1000)
    
    for j in range(sizes[1]):  # for each angular frequency
        for i in range(sizes[0]):  # for each detector spatial frequency
            phi = starts[1] + j*steps[1]
            rx = starts[0] + i*steps[0]
            if ( abs(rx) > bw_i):
               band_limit[i,j] = 0.0
            elif ( abs(rx) < 0.9*bw_i):
               band_limit[i,j] = 1.0
            elif ( abs(rx) > 0.9*bw_i and abs(rx) < bw_i):
               band_limit[i,j] = cos(pi/2.0*(rx-0.9*bw_i)/(0.1*bw_i))**2 
       
    return band_limit
      
def psf_in_fdr_space(sizes, steps, starts, psf, psf_starts,psf_steps,psf_sizes):
    """compute the psf in FDR space where the latter has coordinates of spatial frequency and angular frequency

    sizes  :  (Nx, Nphi)   dimensions of image
    steps  :  (sx, sphi)   voxel size in x and l dimensions
    starts :  (cx, cphi)   centre of 0,0 voxel
    psf    :  ArrayVolume specifying psf

    """
    """
    print sizes
    print steps
    print starts
    print psf_sizes
    print psf_steps
    """

    #print psf_starts
    
    # alloc array
    h = zeros([sizes[0], sizes[1]], complex_)
    
    # compute fft of psf along detector element dimension (x)
    zero_offset = psf.shape[1]/2
    
    rx_psf = roll(fftpack.fft(psf[0], axis=0) , zero_offset, axis=0)
    #print rx_psf.shape (1024, 785)
    rx_values = arange(-zero_offset, psf_sizes[1]-zero_offset)/(psf_steps[1]*psf_sizes[1]) 
    #print rx_values.shape (1024,)
    l_values = psf_starts[2] + arange(psf_sizes[2])*psf_steps[2]
    #print l_values
    #print l_values.shape (785,)
    interp_rx_psf = bilinear_interp(rx_values, l_values, rx_psf)
    #interp_rx_psf = RectBivariateSpline(rx_values,l_values,rx_psf,kx=1,ky=1)
    #print interp_rx_psf
    # evaluate each voxel
    for j in range(sizes[1]):  # for each angular frequency
        for i in range(sizes[0]):  # for each detector spatial frequency
            phi = starts[1] + j*steps[1]
            rx  = starts[0] + i*steps[0]
            if (abs(rx) > 1e-9):
                
                l = -phi/rx   # convert slope to depth
                #print interp_rx_psf(rx, l)

                h[i,j] = interp_rx_psf(rx, l)
                #print 'rx', rx, 'l', l
            else:
                h[i,j] = 0.0
               

    return h
    

class bilinear_interp:
    "bilinear interpolation of 2D data in a regular grid"
    def __init__(self, x, y, z):
        self.x0 = array([x[0], y[0]]) # rx_values
        #print self.x0,'x0'
        #print x[0], x[1]
        #print y[0], y[1]
        self.xstep = array([x[1]-x[0], y[1]-y[0]]) #l_values
        #print self.xstep,'setp'
        self.z = z #rx_psf

    def __call__(self, x,y):
        "evaluate function at point x, y"
        #print  self.x0,'x0'

        point = (array([x,y]) - self.x0)/self.xstep
        #print 'point',point
        p = floor(point)
        u = point - p
        #print u[0], u[1]
       	if (p[0] < 0 or p[1] < 0 or p[0] >= self.z.shape[0]-1 or p[1] >= self.z.shape[1]-1):
            return 0.0
        else:
            c2 = self.z[p[0]:p[0]+2, p[1]:p[1]+2]
            #print c2, 'c2'
            #print c2[1]
            #print c2[0]
            #print '******************'
            d2 = c2[1] - c2[0]
            #print d2 ,'(two comp)'
            # u[0] one comp
            #print 'd2',d2
            #pprint 'u',u[0]
            c1 = c2[0]+u[0]*d2
            #print 'c1', c1
            #pprint 'c11',c1[1]
            #pprint 'c10',c1[0]
            d1 = c1[1] - c1[0]
            
            value = c1[0] + u[1]*d1
            #print value, 'val' 
            # returns one complex number from psf(fft) file 
            return value
